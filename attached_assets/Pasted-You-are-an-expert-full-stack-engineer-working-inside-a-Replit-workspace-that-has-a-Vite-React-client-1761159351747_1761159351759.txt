You are an expert full-stack engineer working inside a Replit workspace that has a Vite/React client and an Express/TypeScript server. Your job is to make Sign Up / Sign In work end-to-end and start both apps so Mike can test immediately.

### GOALS
1) Wire up an Express API with sessions/cookies and CORS configured correctly for Replit.
2) Implement auth routes: POST /api/auth/register, POST /api/auth/login, POST /api/auth/logout, GET /api/auth/me.
3) Add a Vite proxy so the client can call /api/* without hardcoding host/port.
4) Ensure Prisma schema includes User { id, email, hash, role, name } and is migrated.
5) Start the server on port 3000 and the client on port 5173 and confirm they work.

### STACK CONSTRAINTS
- Frontend: Vite + React + TypeScript.
- Backend: Express + TypeScript.
- ORM: Prisma with **PostgreSQL** (use DATABASE_URL from Replit Secrets).
- Sessions: express-session (cookie-based).
- Passwords: bcrypt.
- Replit: no Docker. Two processes (server & client) running in separate shell tabs is fine.

### CREATE / UPDATE FILES EXACTLY AS FOLLOWS

1) server/cors.ts  (CORS with credentials)
------------------------------------------------
import cors from "cors";

const allowedOrigins = [
  "http://localhost:5173",
  // Add your Replit preview origin(s) here automatically at runtime if available:
];

export const corsMiddleware = cors({
  origin: (origin, cb) => {
    if (!origin) return cb(null, true);
    // allow localhost and any *.repl.co / *.repl.dev origins
    if (
      origin.startsWith("http://localhost:5173") ||
      /\.repl\.co$/.test(new URL(origin).host) ||
      /\.repl\.dev$/.test(new URL(origin).host)
    ) return cb(null, true);
    return cb(null, false);
  },
  credentials: true,
});
export default corsMiddleware;

2) server/routes/auth.ts  (auth endpoints)
------------------------------------------------
import { Router } from "express";
import bcrypt from "bcrypt";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();
const r = Router();
const SALT_ROUNDS = parseInt(process.env.AUTH_SALT_ROUNDS || "10", 10);

r.post("/register", async (req, res) => {
  try {
    const { email, password, name } = req.body || {};
    if (!email || !password) return res.status(400).json({ error: "email and password required" });

    const existing = await prisma.user.findUnique({ where: { email } });
    if (existing) return res.status(409).json({ error: "Email already registered" });

    const hash = await bcrypt.hash(password, SALT_ROUNDS);
    const user = await prisma.user.create({ data: { email, name: name || null, hash, role: "user" } });

    (req.session as any).uid = user.id;
    res.json({ id: user.id, email: user.email, name: user.name, role: user.role });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Failed to register" });
  }
});

r.post("/login", async (req, res) => {
  try {
    const { email, password } = req.body || {};
    if (!email || !password) return res.status(400).json({ error: "email and password required" });

    const user = await prisma.user.findUnique({ where: { email } });
    if (!user) return res.status(401).json({ error: "Invalid credentials" });

    const ok = await bcrypt.compare(password, user.hash);
    if (!ok) return res.status(401).json({ error: "Invalid credentials" });

    (req.session as any).uid = user.id;
    res.json({ id: user.id, email: user.email, name: user.name, role: user.role });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Failed to login" });
  }
});

r.post("/logout", (req, res) => {
  req.session.destroy(() => res.json({ ok: true }));
});

r.get("/me", async (req, res) => {
  const uid = (req.session as any).uid;
  if (!uid) return res.status(200).json(null);
  const user = await prisma.user.findUnique({
    where: { id: uid },
    select: { id: true, email: true, name: true, role: true },
  });
  res.json(user || null);
});

export default r;

3) server/routes.ts  (router aggregator)
------------------------------------------------
import { Router } from "express";
import auth from "./routes/auth";

const api = Router();
api.use("/auth", auth); // -> /api/auth/*

export default api;

4) server/index.ts  (Express app bootstrap)
------------------------------------------------
import "dotenv/config";
import express from "express";
import cookieParser from "cookie-parser";
import session from "express-session";
import corsMiddleware from "./cors";
import api from "./routes";

const app = express();

app.use(corsMiddleware);
app.use(express.json());
app.use(cookieParser());
app.use(
  session({
    secret: process.env.SESSION_SECRET || "dev_secret_change_me",
    resave: false,
    saveUninitialized: false,
    cookie: {
      httpOnly: true,
      sameSite: "lax",   // if client is on a different domain, use: 'none' and secure:true
      secure: false,     // set true when on https with sameSite:'none'
    },
  })
);

app.use("/api", api);
app.get("/health", (_req, res) => res.json({ ok: true }));

const PORT = process.env.PORT ? Number(process.env.PORT) : 3000;
app.listen(PORT, () => console.log(`API listening on http://localhost:${PORT}`));

export default app;

5) prisma/schema.prisma  (ensure minimal user model)
------------------------------------------------
generator client { provider = "prisma-client-js" }
datasource db { provider = "postgresql"; url = env("DATABASE_URL") }

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  hash      String
  name      String?
  role      Role     @default(user)
  createdAt DateTime @default(now())
}
enum Role { user worker admin }

6) client/vite.config.ts  (proxy /api to server)
------------------------------------------------
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    proxy: {
      "/api": { target: "http://localhost:3000", changeOrigin: true },
    },
  },
});

7) client/src/lib/api.ts  (fetch helper with credentials)
------------------------------------------------
export async function api(path: string, opts: RequestInit = {}) {
  const res = await fetch(path.startsWith("/api") ? path : `/api${path}`, {
    credentials: "include",
    headers: { "Content-Type": "application/json", ...(opts.headers || {}) },
    ...opts,
  });
  const ct = res.headers.get("content-type") || "";
  const data = ct.includes("application/json") ? await res.json() : await res.text();
  if (!res.ok) throw new Error(typeof data === "string" ? data : data?.error || "Request failed");
  return data;
}

8) client/src/pages/Login.tsx  (simple login form)
------------------------------------------------
import { useState } from "react";
import { api } from "../lib/api";

export default function Login() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [err, setErr] = useState<string | null>(null);

  async function onSubmit(e: React.FormEvent) {
    e.preventDefault();
    setErr(null);
    try {
      await api("/auth/login", { method: "POST", body: JSON.stringify({ email, password }) });
      window.location.href = "/dashboard";
    } catch (e:any) {
      setErr(e.message || "Login failed");
    }
  }

  return (
    <form onSubmit={onSubmit} className="space-y-3">
      {err && <div className="text-red-600 text-sm">{err}</div>}
      <input value={email} onChange={e=>setEmail(e.target.value)} placeholder="Email" />
      <input value={password} onChange={e=>setPassword(e.target.value)} placeholder="Password" type="password" />
      <button type="submit">Sign in</button>
    </form>
  );
}

9) client/src/pages/Register.tsx  (simple register form)
------------------------------------------------
import { useState } from "react";
import { api } from "../lib/api";

export default function Register() {
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [err, setErr] = useState<string | null>(null);

  async function onSubmit(e: React.FormEvent) {
    e.preventDefault();
    setErr(null);
    try {
      await api("/auth/register", { method: "POST", body: JSON.stringify({ name, email, password }) });
      window.location.href = "/dashboard";
    } catch (e:any) {
      setErr(e.message || "Register failed");
    }
  }

  return (
    <form onSubmit={onSubmit} className="space-y-3">
      {err && <div className="text-red-600 text-sm">{err}</div>}
      <input value={name} onChange={e=>setName(e.target.value)} placeholder="Name" />
      <input value={email} onChange={e=>setEmail(e.target.value)} placeholder="Email" />
      <input value={password} onChange={e=>setPassword(e.target.value)} placeholder="Password" type="password" />
      <button type="submit">Create account</button>
    </form>
  );
}

10) server/package.json scripts  (dev/start)
------------------------------------------------
Add or update:
{
  "scripts": {
    "dev": "nodemon --watch . --ext ts,js --exec ts-node server/index.ts",
    "start": "node dist/index.js",
    "prisma:gen": "prisma generate",
    "prisma:migrate": "prisma migrate dev --name init"
  }
}

11) client/package.json scripts  (dev)
------------------------------------------------
Ensure:
{
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview --port 5173"
  }
}

### ENV & SETUP (Agent do these steps)
- Open Replit Secrets and set:
  - DATABASE_URL = (Postgres URL)
  - SESSION_SECRET = a long random string
  - AUTH_SALT_ROUNDS = 10
- Install server deps in /server: npm i express express-session cookie-parser cors bcrypt dotenv ts-node nodemon @types/express @types/bcrypt @types/node prisma @prisma/client
- Install client deps in /client: npm i
- Prisma:
  - npx prisma init (if not already)
  - Write schema.prisma as above
  - npx prisma generate
  - npx prisma migrate dev --name init

### START PROCESSES (Agent actions)
- Open one Shell tab, run:  (inside /server)
  npm run dev
  Expect: "API listening on http://localhost:3000"
- Open a second Shell tab, run:  (inside /client)
  npm run dev
  Expect: "Local: http://localhost:5173"

### ACCEPTANCE TESTS
1) Visit http://localhost:3000/health â†’ should return {"ok":true}.
2) In the client app, open Login and Register pages:
   - Register a new user.
   - Login with that user.
   - In DevTools Network, /api/auth/login returns 200 and sets a Set-Cookie header.
   - After login, GET /api/auth/me returns the user object.
3) If frontend and API are on different domains, switch session cookie to sameSite:'none', secure:true (in server/index.ts) and retest.

### OUTPUT BACK TO ME
- Confirm urls shown by Vite and the API.
- Confirm that register/login succeeded.
- If anything failed, paste the exact error text from the DevTools Console/Network and the last 30 lines of the server log.